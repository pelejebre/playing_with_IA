<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visor de CSV con Gráfico Temporal</title>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f7f6;
            color: #333;
            line-height: 1.6;
        }
        .container {
            max-width: 900px;
            margin: 20px auto;
            padding: 25px;
            background-color: #fff;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        header {
            background-color: #007bff;
            color: white;
            padding: 15px 25px;
            border-radius: 10px 10px 0 0;
            text-align: center;
            margin-bottom: 20px;
        }
        header h1 {
            margin: 0;
            font-size: 1.8em;
        }
        .control-group {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background-color: #fdfdfd;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #0056b3;
        }
        input[type="file"] {
            display: none; 
        }
        .file-upload-button, select, input[type="text"], input[type="date"] {
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-sizing: border-box;
            font-size: 1em;
        }
        .file-upload-button {
            background-color: #28a745;
            color: white;
            cursor: pointer;
            text-align: center;
            transition: background-color 0.2s;
        }
        .file-upload-button:hover {
            background-color: #218838;
        }
        #fileSearch {
             margin-bottom: 5px;
        }
        #fileList {
            height: 120px; 
        }
        #chartContainer {
            width: 100%;
            min-height: 400px;
            margin-top: 20px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 10px;
            box-sizing: border-box;
        }
        .info-text {
            font-size: 0.9em;
            color: #666;
            margin-top: 5px;
        }
        .hidden {
            display: none;
        }
        .date-picker-group {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            margin-bottom: 10px;
        }
        .date-picker-item {
            flex: 1;
        }
        .date-picker-item label {
            font-size: 0.9em;
            margin-bottom: 3px;
            color: #333;
        }
        .date-picker-item input[type="date"] {
            width: 100%; 
            padding: 8px;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Visor Interactivo de Datos CSV</h1>
        </header>

        <div class="control-group">
            <label for="fileUploadButton">1. Cargar Archivos CSV</label>
            <input type="file" id="csvFileInput" accept=".csv" multiple>
            <button class="file-upload-button" id="fileUploadButton">Seleccionar Archivos CSV</button>
            <p class="info-text">Los archivos cargados aparecerán abajo. Puedes buscar y seleccionar uno.</p>
        </div>
        
        <div class="control-group">
            <label for="fileSearch">Buscar archivo cargado:</label>
            <input type="text" id="fileSearch" placeholder="Escribe para filtrar archivos...">
            <label for="fileList">Seleccionar CSV cargado:</label>
            <select id="fileList" size="5">
                <option value="" disabled selected>Carga archivos para verlos aquí</option>
            </select>
        </div>

        <div class="control-group">
            <label for="columnSelector">2. Seleccionar Columna para Graficar</label>
            <select id="columnSelector" disabled>
                <option value="">Primero selecciona un archivo CSV</option>
            </select>
        </div>

        <div class="control-group hidden" id="dateRangeControls">
            <label>3. Seleccionar Rango de Fechas (si aplica)</label>
            <div class="date-picker-group">
                <div class="date-picker-item">
                    <label for="startDateInput">Fecha Inicio:</label>
                    <input type="date" id="startDateInput" disabled>
                </div>
                <div class="date-picker-item">
                    <label for="endDateInput">Fecha Fin:</label>
                    <input type="date" id="endDateInput" disabled>
                </div>
            </div>
        </div>

        <div class="control-group">
            <label for="chartTypeSelector">4. Seleccionar Tipo de Gráfico</label>
            <select id="chartTypeSelector" disabled>
                <option value="line">Líneas (Temporal)</option>
                <option value="histogram">Histograma</option>
                <option value="boxplot">Diagrama de Caja (Boxplot)</option>
                <option value="acf">Autocorrelación (ACF)</option>
            </select>
        </div>

        <div id="chartContainer">
            <p class="info-text" id="chartPlaceholder">El gráfico aparecerá aquí una vez selecciones una columna.</p>
        </div>
    </div>

    <script>
        const csvFileInput = document.getElementById('csvFileInput');
        const fileUploadButton = document.getElementById('fileUploadButton');
        const fileSearch = document.getElementById('fileSearch');
        const fileList = document.getElementById('fileList');
        const columnSelector = document.getElementById('columnSelector');
        const chartTypeSelector = document.getElementById('chartTypeSelector');
        const chartContainer = document.getElementById('chartContainer');
        const chartPlaceholder = document.getElementById('chartPlaceholder');
        
        const dateRangeControls = document.getElementById('dateRangeControls');
        const startDateInput = document.getElementById('startDateInput'); 
        const endDateInput = document.getElementById('endDateInput');   

        let loadedCsvFiles = []; 
        let currentFileDateValues = []; 

        fileUploadButton.addEventListener('click', () => csvFileInput.click());
        csvFileInput.addEventListener('change', handleFiles);
        fileSearch.addEventListener('input', filterFileList);
        fileList.addEventListener('change', handleFileSelection);
        columnSelector.addEventListener('change', setupPlottingControls);
        chartTypeSelector.addEventListener('change', plotData);
        
        startDateInput.addEventListener('change', handleDateInputChange);
        endDateInput.addEventListener('change', handleDateInputChange);

                function handleFiles(event) {
            const files = Array.from(event.target.files);
            let filesProcessed = 0;
            if (files.length === 0) return;
        
            files.forEach(file => {
                if (file.name.toLowerCase().endsWith('.csv')) {
                    if (loadedCsvFiles.find(f => f.name === file.name)) {
                        filesProcessed++;
                        if (filesProcessed === files.length) updateFileList();
                        return;
                    }
                    Papa.parse(file, {
                        header: true,
                        skipEmptyLines: true,
                        dynamicTyping: false, // Cambiado a false para manejar fechas como strings
                        complete: function(results) {
                            const headers = results.meta.fields;
                            if (!headers || headers.length === 0) {
                                alert(`El archivo ${file.name} no tiene cabeceras o está vacío.`);
                                filesProcessed++;
                                if (filesProcessed === files.length) updateFileList();
                                return;
                            }
        
                            // Verificar que las primeras dos columnas sean Fecha y Hora
                            if (headers.length < 2) {
                                alert(`El archivo ${file.name} debe tener al menos 2 columnas (Fecha y Hora).`);
                                filesProcessed++;
                                if (filesProcessed === files.length) updateFileList();
                                return;
                            }
        
                            const fechaColumn = headers[0];
                            const horaColumn = headers[1];
                            
                            // Procesar y ordenar los datos por fecha-hora
                            const processedData = results.data
                                .filter(row => row[fechaColumn] && row[horaColumn] !== undefined)
                                .map(row => {
                                    // Crear datetime combinando fecha y hora
                                    const fechaStr = String(row[fechaColumn]).trim();
                                    const horaNum = parseInt(row[horaColumn]);
                                    
                                    // Convertir fecha de dd/mm/yyyy a yyyy-mm-dd para crear Date
                                    const fechaParts = fechaStr.split('/');
                                    if (fechaParts.length === 3) {
                                        const [dia, mes, año] = fechaParts;
                                        const fechaISO = `${año}-${mes.padStart(2, '0')}-${dia.padStart(2, '0')}`;
                                        const datetime = new Date(`${fechaISO}T${String(horaNum).padStart(2, '0')}:00:00`);
                                        
                                        if (!isNaN(datetime.getTime())) {
                                            return {
                                                ...row,
                                                _datetime: datetime,
                                                _datetimeString: `${fechaStr} ${horaNum}:00`
                                            };
                                        }
                                    }
                                    return null;
                                })
                                .filter(row => row !== null)
                                .sort((a, b) => a._datetime - b._datetime); // Ordenar por datetime
        
                            if (processedData.length === 0) {
                                alert(`No se pudieron procesar las fechas y horas en ${file.name}. Verifica el formato (dd/mm/yyyy para fecha, número entero para hora).`);
                                filesProcessed++;
                                if (filesProcessed === files.length) updateFileList();
                                return;
                            }
        
                            // Crear array de fechas-horas para el selector de rangos
                            const allDatesForFile = processedData.map(row => row._datetimeString);
        
                            loadedCsvFiles.push({
                                name: file.name, 
                                data: processedData, 
                                headers: headers, 
                                allDates: allDatesForFile,
                                hasRealDates: true,
                                fechaColumn: fechaColumn,
                                horaColumn: horaColumn
                            });
                            
                            filesProcessed++;
                            if (filesProcessed === files.length) updateFileList();
                        },
                        error: (error) => {
                            alert(`Error al procesar ${file.name}: ${error.message}`);
                            filesProcessed++;
                            if (filesProcessed === files.length) updateFileList();
                        }
                    });
                } else {
                    alert(`El archivo ${file.name} no es un CSV.`);
                    filesProcessed++;
                    if (filesProcessed === files.length) updateFileList();
                }
            });
            csvFileInput.value = ''; 
        }

        function updateFileList() {
            const searchTerm = fileSearch.value.toLowerCase();
            const previouslySelectedFile = fileList.value;
            fileList.innerHTML = '';
            const filteredFiles = loadedCsvFiles.filter(f => f.name.toLowerCase().includes(searchTerm));

            if (filteredFiles.length === 0) {
                const opt = new Option(loadedCsvFiles.length > 0 ? "Ningún archivo coincide" : "Carga archivos para verlos aquí", "");
                opt.disabled = true; opt.selected = true;
                fileList.add(opt);
                resetAllControls();
            } else {
                filteredFiles.forEach(f => fileList.add(new Option(f.name, f.name)));
                if (filteredFiles.some(f => f.name === previouslySelectedFile)) {
                    fileList.value = previouslySelectedFile;
                } else if (filteredFiles.length > 0) {
                    fileList.value = filteredFiles[0].name;
                }
                handleFileSelection(); 
            }
        }
        
        function filterFileList() { updateFileList(); }

        function resetAllControls() {
            resetColumnSelector();
            resetDateControls(); 
            resetChartTypeSelector(); 
            Plotly.purge(chartContainer);
            chartPlaceholder.classList.remove('hidden');
            chartPlaceholder.textContent = "Carga archivos para visualizarlos.";
        }

        function resetColumnSelector() {
            columnSelector.innerHTML = '<option value="" selected>Primero selecciona un archivo CSV</option>';
            columnSelector.disabled = true;
        }

        function resetChartTypeSelector() {
            chartTypeSelector.disabled = true;
            chartTypeSelector.value = "line";
        }

        function resetDateControls() {
            dateRangeControls.classList.add('hidden');
            [startDateInput, endDateInput].forEach(el => { el.disabled = true; el.value = ''; el.min = ''; el.max = '';});
            currentFileDateValues = [];
        }

        function handleFileSelection() {
            const selectedFileName = fileList.value;
            resetColumnSelector();
            resetDateControls(); 
            resetChartTypeSelector();
            Plotly.purge(chartContainer);
            chartPlaceholder.classList.remove('hidden');
            chartPlaceholder.textContent = "Selecciona una columna para graficar.";

            if (!selectedFileName) return;

            const selectedFile = loadedCsvFiles.find(f => f.name === selectedFileName);
            if (selectedFile) {
                columnSelector.innerHTML = '<option value="" selected>Selecciona una columna</option>';
                selectedFile.headers.forEach(h => columnSelector.add(new Option(h, h)));
                columnSelector.disabled = false;
                currentFileDateValues = selectedFile.allDates || [];
                // If a column was previously selected for this file, re-select it and setup controls
                // This part might need more sophisticated state management if desired
                if (columnSelector.options.length > 1) {
                     // Optionally, trigger setupPlottingControls if a default column should be plotted
                     // or if state needs to be restored. For now, user must select a column.
                }
            }
        }
        
                function valueToInputDate(value) { 
            if (value == null) return "";
            
            const dateStr = String(value);
            
            // Manejar formato "dd/mm/yyyy HH:mm" o "dd/mm/yyyy H"
            const dateTimeMatch = dateStr.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})\s+(\d{1,2})/);
            if (dateTimeMatch) {
                const [, dia, mes, año, hora] = dateTimeMatch;
                const fechaISO = `${año}-${mes.padStart(2, '0')}-${dia.padStart(2, '0')}`;
                return fechaISO;
            }
            
            // Fallback para otros formatos
            const d = new Date(dateStr);
            if (!isNaN(d.getTime()) && d.toString() !== "Invalid Date") {
                if (d.getFullYear() > 1000 && d.getFullYear() < 3000) {
                    return d.toISOString().split('T')[0];
                }
            }
            
            return "";
        }

        function setupPlottingControls() { 
            const selectedFile = loadedCsvFiles.find(f => f.name === fileList.value);
            const selectedColumnValue = columnSelector.value;

            resetDateControls(); 
            resetChartTypeSelector(); 

            if (!selectedFile || !selectedColumnValue) {
                plotData(); 
                return;
            }
            
            // Configure date controls only if the file was determined to have real dates
            // and currentFileDateValues has items.
            if (selectedFile.hasRealDates && currentFileDateValues.length > 0) {
                const minDateForInput = valueToInputDate(currentFileDateValues[0]);
                const maxDateForInput = valueToInputDate(currentFileDateValues[currentFileDateValues.length - 1]);

                if (minDateForInput && maxDateForInput) {
                    dateRangeControls.classList.remove('hidden'); 
                    startDateInput.min = minDateForInput;
                    startDateInput.max = maxDateForInput;
                    startDateInput.value = minDateForInput;
                    startDateInput.disabled = false; 
                    
                    endDateInput.min = minDateForInput;
                    endDateInput.max = maxDateForInput;
                    endDateInput.value = maxDateForInput;
                    endDateInput.disabled = false;
                } else {
                    dateRangeControls.classList.add('hidden'); 
                }
            } else {
                 dateRangeControls.classList.add('hidden'); 
            }

            chartTypeSelector.disabled = false; 
            plotData(); 
        }

        function handleDateInputChange() {
            if (startDateInput.value && endDateInput.value && startDateInput.value > endDateInput.value) {
                if (this.id === 'startDateInput') endDateInput.value = startDateInput.value; 
                else startDateInput.value = endDateInput.value; 
            }
            plotData();
        }

        function calculateACF(data, maxLag) {
            const n = data.length;
            if (n === 0) return [];
            const mean = data.reduce((a, b) => a + b) / n;
            const variance = data.reduce((acc, val) => acc + (val - mean) * (val - mean), 0);
            
            const acfValues = [];
            for (let lag = 0; lag <= maxLag; lag++) {
                if (lag === 0) {
                    acfValues.push(1);
                    continue;
                }
                if (lag >= n) {
                    acfValues.push(0);
                    continue;
                }
                let covariance = 0;
                for (let i = 0; i < n - lag; i++) {
                    covariance += (data[i] - mean) * (data[i + lag] - mean);
                }
                acfValues.push(variance === 0 ? 0 : covariance / variance);
            }
            return acfValues;
        }


                function plotData() {
            const selectedFileName = fileList.value;
            const selectedColumn = columnSelector.value;
            const selectedChartType = chartTypeSelector.value;
            const selectedFile = loadedCsvFiles.find(f => f.name === selectedFileName);
        
            if (!selectedFile || !selectedColumn) { 
                Plotly.purge(chartContainer); 
                chartPlaceholder.classList.remove('hidden');
                chartPlaceholder.textContent = "Selecciona un archivo y una columna para graficar.";
                if (!selectedColumn) dateRangeControls.classList.add('hidden');
                return; 
            }
        
            if (!selectedFile.data) return;
        
            // Usar los datos ya ordenados por datetime
            const originalXValues = selectedFile.data.map(row => row._datetimeString);
            const originalYValues = selectedFile.data.map(row => row[selectedColumn]);
            
            let xDataForPlot = [...originalXValues]; 
            let yDataForPlot = [...originalYValues]; 
        
            // Filtrar por rango de fechas si está configurado
            if (selectedFile.hasRealDates && !dateRangeControls.classList.contains('hidden') && 
                !startDateInput.disabled && startDateInput.value && 
                !endDateInput.disabled && endDateInput.value) {
                
                const inputStartDate = startDateInput.value; 
                const inputEndDate = endDateInput.value;     
                
                const filteredIndices = [];
                for(let i = 0; i < selectedFile.data.length; i++) {
                    const rowDateTime = selectedFile.data[i]._datetime;
                    const comparableDate = rowDateTime.toISOString().split('T')[0];
                    
                    if (comparableDate >= inputStartDate && comparableDate <= inputEndDate) {
                        filteredIndices.push(i);
                    }
                }
                xDataForPlot = filteredIndices.map(i => originalXValues[i]);
                yDataForPlot = filteredIndices.map(i => originalYValues[i]);
            }
            
            const numericYValues = yDataForPlot.map(val => { 
                const num = parseFloat(String(val).replace(',', '.')); 
                return isNaN(num) ? null : num; 
            }).filter(val => val !== null); 
        
            let plotConfig = [];
            let layout = {
                title: `${selectedChartType.charAt(0).toUpperCase() + selectedChartType.slice(1)} para: ${selectedColumn}`,
                margin: { l: 60, r: 30, b: 80, t: 50 },
                hovermode: 'closest'
            };
        
            if (numericYValues.length === 0 && selectedChartType !== 'line' && selectedChartType !== 'acf') {
                 Plotly.purge(chartContainer);
                 chartPlaceholder.textContent = "No hay datos numéricos válidos en la columna seleccionada para el rango/tipo especificado.";
                 chartPlaceholder.classList.remove('hidden');
                 return;
            }
        
            switch (selectedChartType) {
                case 'line':
                    const lineYValues = yDataForPlot.map(val => { 
                        const num = parseFloat(String(val).replace(',', '.')); 
                        return isNaN(num) ? null : num; 
                    });
                    
                    if (xDataForPlot.length === 0 || lineYValues.every(v => v === null)) {
                        Plotly.purge(chartContainer);
                        chartPlaceholder.textContent = "No hay datos para mostrar con el filtro de fecha actual o la columna no es numérica.";
                        chartPlaceholder.classList.remove('hidden');
                        return;
                    }
                    
                    plotConfig = [{
                        x: xDataForPlot, 
                        y: lineYValues,
                        type: 'scatter', 
                        mode: 'lines+markers', 
                        name: selectedColumn,
                        line: {shape: 'spline'}, 
                        marker: { size: 4 }
                    }];
                    layout.xaxis = { 
                        title: 'Fecha-Hora',
                        type: 'category',
                        tickangle: -45
                    };
                    layout.yaxis = { title: selectedColumn };
                    break;
                    
                case 'histogram':
                    if (numericYValues.length === 0) {
                        Plotly.purge(chartContainer);
                        chartPlaceholder.textContent = "No hay datos numéricos para el histograma.";
                        chartPlaceholder.classList.remove('hidden');
                        return;
                    }
                    plotConfig = [{
                        x: numericYValues,
                        type: 'histogram',
                        name: selectedColumn,
                        marker: { color: '#007bff' }
                    }];
                    layout.xaxis = { title: selectedColumn };
                    layout.yaxis = { title: 'Frecuencia' };
                    break;
                    
                case 'boxplot':
                     if (numericYValues.length === 0) {
                        Plotly.purge(chartContainer);
                        chartPlaceholder.textContent = "No hay datos numéricos para el diagrama de caja.";
                        chartPlaceholder.classList.remove('hidden');
                        return;
                    }
                    plotConfig = [{
                        y: numericYValues, 
                        type: 'box',
                        name: selectedColumn,
                        marker: { color: '#28a745' }
                    }];
                    layout.xaxis = { title: '' };
                    layout.yaxis = { title: selectedColumn };
                    break;
                    
                case 'acf':
                    if (numericYValues.length < 2) {
                        Plotly.purge(chartContainer);
                        chartPlaceholder.textContent = "Se necesitan al menos 2 puntos de datos numéricos para calcular ACF.";
                        chartPlaceholder.classList.remove('hidden');
                        return;
                    }
                    const maxLag = Math.min(numericYValues.length - 1, 40);
                    const acfValues = calculateACF(numericYValues, maxLag); 
                    const lags = Array.from({length: acfValues.length}, (_, i) => i);
                    const confidenceLimit = 1.96 / Math.sqrt(numericYValues.length);
                    
                    plotConfig = [
                        { 
                            x: lags, 
                            y: acfValues, 
                            type: 'bar', 
                            name: 'ACF', 
                            marker: { color: '#ff7f0e' } 
                        },
                        { 
                            x: [lags[0], lags[lags.length - 1]], 
                            y: [confidenceLimit, confidenceLimit], 
                            type: 'scatter', 
                            mode: 'lines', 
                            name: 'Conf. Superior', 
                            line: { color: 'rgba(0,0,0,0.5)', dash: 'dash' } 
                        },
                        { 
                            x: [lags[0], lags[lags.length - 1]], 
                            y: [-confidenceLimit, -confidenceLimit], 
                            type: 'scatter', 
                            mode: 'lines', 
                            name: 'Conf. Inferior', 
                            line: { color: 'rgba(0,0,0,0.5)', dash: 'dash' } 
                        }
                    ];
                    layout.xaxis = { title: 'Lag' };
                    layout.yaxis = { title: 'Autocorrelación', range: [-1, 1] };
                    layout.showlegend = true;
                    break;
                    
                default:
                    Plotly.purge(chartContainer);
                    chartPlaceholder.textContent = "Tipo de gráfico no reconocido.";
                    chartPlaceholder.classList.remove('hidden');
                    return;
            }
        
            if (plotConfig.length > 0 && plotConfig.some(trace => (trace.x && trace.x.length > 0) || (trace.y && trace.y.length > 0))) {
                chartPlaceholder.classList.add('hidden');
                Plotly.newPlot(chartContainer, plotConfig, layout, {responsive: true});
            } else {
                Plotly.purge(chartContainer);
                chartPlaceholder.textContent = "No hay datos para mostrar con la configuración actual.";
                chartPlaceholder.classList.remove('hidden');
            }
        }
        updateFileList(); // Initial call to set up the file list area
    </script>
</body>
</html>