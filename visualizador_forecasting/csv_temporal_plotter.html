<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visor de CSV con Gráfico Temporal</title>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f7f6;
            color: #333;
            line-height: 1.6;
        }
        .container {
            max-width: 900px;
            margin: 20px auto;
            padding: 25px;
            background-color: #fff;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        header {
            background-color: #007bff;
            color: white;
            padding: 15px 25px;
            border-radius: 10px 10px 0 0;
            text-align: center;
            margin-bottom: 20px;
        }
        header h1 {
            margin: 0;
            font-size: 1.8em;
        }
        .control-group {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background-color: #fdfdfd;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #0056b3;
        }
        input[type="file"] {
            display: none; 
        }
        .file-upload-button, select, input[type="text"], input[type="date"] {
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-sizing: border-box;
            font-size: 1em;
        }
        .file-upload-button {
            background-color: #28a745;
            color: white;
            cursor: pointer;
            text-align: center;
            transition: background-color 0.2s;
        }
        .file-upload-button:hover {
            background-color: #218838;
        }
        #fileSearch {
             margin-bottom: 5px;
        }
        #fileList {
            height: 120px; 
        }
        #chartContainer {
            width: 100%;
            min-height: 400px;
            margin-top: 20px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 10px;
            box-sizing: border-box;
        }
        .info-text {
            font-size: 0.9em;
            color: #666;
            margin-top: 5px;
        }
        .hidden {
            display: none;
        }
        .date-picker-group {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            margin-bottom: 10px;
        }
        .date-picker-item {
            flex: 1;
        }
        .date-picker-item label {
            font-size: 0.9em;
            margin-bottom: 3px;
            color: #333;
        }
        .date-picker-item input[type="date"] {
            width: 100%; 
            padding: 8px;
            margin-bottom: 5px;
        }
        .filter-options {
            margin-bottom: 15px;
        }
        .filter-options label {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-weight: normal;
            cursor: pointer;
        }
        .filter-options input[type="radio"] {
            margin-right: 8px;
            width: auto;
        }
        .date-picker-group.disabled {
            opacity: 0.5;
            pointer-events: none;
        }
        #dateFilterInfo {
            margin-top: 10px;
            font-style: italic;
        }
        .analysis-options {
            margin-bottom: 15px;
        }
        .analysis-options label {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-weight: normal;
            cursor: pointer;
        }
        .analysis-options input[type="checkbox"] {
            margin-right: 8px;
            width: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Visor Interactivo de Datos CSV</h1>
        </header>

        <div class="control-group">
            <label for="fileUploadButton">1. Cargar Archivos CSV</label>
            <input type="file" id="csvFileInput" accept=".csv" multiple>
            <button class="file-upload-button" id="fileUploadButton">Seleccionar Archivos CSV</button>
            <p class="info-text">Los archivos cargados aparecerán abajo. Puedes buscar y seleccionar uno.</p>
        </div>
        
        <div class="control-group">
            <label for="fileSearch">Buscar archivo cargado:</label>
            <input type="text" id="fileSearch" placeholder="Escribe para filtrar archivos...">
            <label for="fileList">Seleccionar CSV cargado:</label>
            <select id="fileList" size="5">
                <option value="" disabled selected>Carga archivos para verlos aquí</option>
            </select>
        </div>

        <div class="control-group">
            <label for="columnSelector">2. Seleccionar Columna para Graficar</label>
            <select id="columnSelector" disabled>
                <option value="">Primero selecciona un archivo CSV</option>
            </select>
        </div>

        <div class="control-group">
            <label for="chartTypeSelector">3. Seleccionar Tipo de Gráfico</label>
            <select id="chartTypeSelector" disabled>
                <option value="line">Líneas (Temporal)</option>
                <option value="histogram">Histograma</option>
                <option value="boxplot">Diagrama de Caja (Boxplot)</option>
                <option value="acf">Autocorrelación (ACF)</option>
            </select>
        </div>

        <div class="control-group" id="dateFilterControls" style="display: none;">
            <label>4. Filtrar por Rango de Fechas</label>
            <div class="filter-options">
                <label>
                    <input type="radio" name="dateFilter" value="all" checked> Mostrar todos los datos
                </label>
                <label>
                    <input type="radio" name="dateFilter" value="range"> Filtrar por rango de fechas
                </label>
            </div>
            <div class="date-picker-group disabled" id="dateRangeInputs">
                <div class="date-picker-item">
                    <label for="startDateInput">Fecha Inicio:</label>
                    <input type="date" id="startDateInput" disabled>
                </div>
                <div class="date-picker-item">
                    <label for="endDateInput">Fecha Fin:</label>
                    <input type="date" id="endDateInput" disabled>
                </div>
            </div>
            <p class="info-text" id="dateFilterInfo">Selecciona "Filtrar por rango de fechas" para activar el filtrado.</p>
        </div>

        <div class="control-group" id="analysisControls" style="display: none;">
            <label>5. Análisis de Serie Temporal</label>
            <div class="analysis-options">
                <label>
                    <input type="checkbox" id="showTrend" checked> Mostrar Tendencia
                </label>
                <label>
                    <input type="checkbox" id="showSeasonality" checked> Mostrar Estacionalidad
                </label>
            </div>
            <p class="info-text">Marca las opciones para mostrar el análisis de la serie temporal en el gráfico.</p>
        </div>

        <div id="chartContainer">
            <p class="info-text" id="chartPlaceholder">El gráfico aparecerá aquí una vez selecciones una columna.</p>
        </div>
    </div>

    <script>
        const csvFileInput = document.getElementById('csvFileInput');
        const fileUploadButton = document.getElementById('fileUploadButton');
        const fileSearch = document.getElementById('fileSearch');
        const fileList = document.getElementById('fileList');
        const columnSelector = document.getElementById('columnSelector');
        const chartTypeSelector = document.getElementById('chartTypeSelector');
        const chartContainer = document.getElementById('chartContainer');
        const chartPlaceholder = document.getElementById('chartPlaceholder');
        
        const dateFilterControls = document.getElementById('dateFilterControls');
        const dateRangeInputs = document.getElementById('dateRangeInputs');
        const dateFilterInfo = document.getElementById('dateFilterInfo');
        const startDateInput = document.getElementById('startDateInput'); 
        const endDateInput = document.getElementById('endDateInput');
        
        const analysisControls = document.getElementById('analysisControls');
        const showTrendCheckbox = document.getElementById('showTrend');
        const showSeasonalityCheckbox = document.getElementById('showSeasonality');

        let loadedCsvFiles = []; 
        let currentFileDateValues = []; 

        fileUploadButton.addEventListener('click', () => csvFileInput.click());
        csvFileInput.addEventListener('change', handleFiles);
        fileSearch.addEventListener('input', filterFileList);
        fileList.addEventListener('change', handleFileSelection);
        columnSelector.addEventListener('change', setupPlottingControls);
        chartTypeSelector.addEventListener('change', handleChartTypeChange);
        
        startDateInput.addEventListener('change', handleDateInputChange);
        endDateInput.addEventListener('change', handleDateInputChange);

        // Agregar event listeners para los radio buttons
        document.querySelectorAll('input[name="dateFilter"]').forEach(radio => {
            radio.addEventListener('change', handleDateFilterChange);
        });

        // Agregar event listeners para los checkboxes de análisis
        showTrendCheckbox.addEventListener('change', plotData);
        showSeasonalityCheckbox.addEventListener('change', plotData);

        function handleChartTypeChange() {
            const selectedChartType = chartTypeSelector.value;
            
            // Mostrar/ocultar controles de análisis según el tipo de gráfico
            if (selectedChartType === 'line') {
                const selectedFile = loadedCsvFiles.find(f => f.name === fileList.value);
                const selectedColumn = columnSelector.value;
                if (selectedFile && selectedColumn) {
                    analysisControls.style.display = 'block';
                }
            } else {
                analysisControls.style.display = 'none';
            }
            
            plotData();
        }

        function handleFiles(event) {
            const files = Array.from(event.target.files);
            let filesProcessed = 0;
            if (files.length === 0) return;

            files.forEach(file => {
                if (file.name.toLowerCase().endsWith('.csv')) {
                    if (loadedCsvFiles.find(f => f.name === file.name)) {
                        filesProcessed++;
                        if (filesProcessed === files.length) updateFileList();
                        return;
                    }
                    Papa.parse(file, {
                        header: true,
                        skipEmptyLines: true,
                        dynamicTyping: false,
                        complete: function(results) {
                            const headers = results.meta.fields;
                            if (!headers || headers.length === 0) {
                                alert(`El archivo ${file.name} no tiene cabeceras o está vacío.`);
                                filesProcessed++;
                                if (filesProcessed === files.length) updateFileList();
                                return;
                            }

                            if (headers.length < 2) {
                                alert(`El archivo ${file.name} debe tener al menos 2 columnas (Fecha y Hora).`);
                                filesProcessed++;
                                if (filesProcessed === files.length) updateFileList();
                                return;
                            }

                            const fechaColumn = headers[0];
                            const horaColumn = headers[1];
                            
                            const processedData = results.data
                                .filter(row => row[fechaColumn] && row[horaColumn] !== undefined)
                                .map(row => {
                                    const fechaStr = String(row[fechaColumn]).trim();
                                    const horaNum = parseInt(row[horaColumn]);
                                    
                                    const fechaParts = fechaStr.split('/');
                                    if (fechaParts.length === 3) {
                                        const [dia, mes, año] = fechaParts;
                                        const fechaISO = `${año}-${mes.padStart(2, '0')}-${dia.padStart(2, '0')}`;
                                        const datetime = new Date(`${fechaISO}T${String(horaNum).padStart(2, '0')}:00:00`);
                                        
                                        if (!isNaN(datetime.getTime())) {
                                            return {
                                                ...row,
                                                _datetime: datetime,
                                                _datetimeString: `${fechaStr} ${horaNum}:00`
                                            };
                                        }
                                    }
                                    return null;
                                })
                                .filter(row => row !== null)
                                .sort((a, b) => a._datetime - b._datetime);

                            if (processedData.length === 0) {
                                alert(`No se pudieron procesar las fechas y horas en ${file.name}. Verifica el formato (dd/mm/yyyy para fecha, número entero para hora).`);
                                filesProcessed++;
                                if (filesProcessed === files.length) updateFileList();
                                return;
                            }

                            const allDatesForFile = processedData.map(row => row._datetimeString);

                            loadedCsvFiles.push({
                                name: file.name, 
                                data: processedData, 
                                headers: headers, 
                                allDates: allDatesForFile,
                                hasRealDates: true,
                                fechaColumn: fechaColumn,
                                horaColumn: horaColumn
                            });
                            
                            filesProcessed++;
                            if (filesProcessed === files.length) updateFileList();
                        },
                        error: (error) => {
                            alert(`Error al procesar ${file.name}: ${error.message}`);
                            filesProcessed++;
                            if (filesProcessed === files.length) updateFileList();
                        }
                    });
                } else {
                    alert(`El archivo ${file.name} no es un CSV.`);
                    filesProcessed++;
                    if (filesProcessed === files.length) updateFileList();
                }
            });
            csvFileInput.value = ''; 
        }

        function updateFileList() {
            const searchTerm = fileSearch.value.toLowerCase();
            const previouslySelectedFile = fileList.value;
            fileList.innerHTML = '';
            const filteredFiles = loadedCsvFiles.filter(f => f.name.toLowerCase().includes(searchTerm));

            if (filteredFiles.length === 0) {
                const opt = new Option(loadedCsvFiles.length > 0 ? "Ningún archivo coincide" : "Carga archivos para verlos aquí", "");
                opt.disabled = true; opt.selected = true;
                fileList.add(opt);
                resetAllControls();
            } else {
                filteredFiles.forEach(f => fileList.add(new Option(f.name, f.name)));
                if (filteredFiles.some(f => f.name === previouslySelectedFile)) {
                    fileList.value = previouslySelectedFile;
                } else if (filteredFiles.length > 0) {
                    fileList.value = filteredFiles[0].name;
                }
                handleFileSelection(); 
            }
        }
        
        function filterFileList() { updateFileList(); }

        function resetAllControls() {
            resetColumnSelector();
            resetDateControls(); 
            resetChartTypeSelector();
            resetAnalysisControls();
            Plotly.purge(chartContainer);
            chartPlaceholder.classList.remove('hidden');
            chartPlaceholder.textContent = "Carga archivos para visualizarlos.";
        }

        function resetColumnSelector() {
            columnSelector.innerHTML = '<option value="" selected>Primero selecciona un archivo CSV</option>';
            columnSelector.disabled = true;
        }

        function resetChartTypeSelector() {
            chartTypeSelector.disabled = true;
            chartTypeSelector.value = "line";
        }

        function resetAnalysisControls() {
            analysisControls.style.display = 'none';
            showTrendCheckbox.checked = true;
            showSeasonalityCheckbox.checked = true;
        }

        function resetDateControls() {
            // Reset radio buttons
            document.querySelector('input[name="dateFilter"][value="all"]').checked = true;
            dateRangeInputs.classList.add('disabled');
            
            [startDateInput, endDateInput].forEach(el => { 
                el.disabled = true; 
                el.value = ''; 
                el.min = ''; 
                el.max = '';
            });
            
            // Solo ocultar el control si NO hay archivo seleccionado o NO tiene fechas válidas
            const selectedFile = loadedCsvFiles.find(f => f.name === fileList.value);
            if (!selectedFile || !selectedFile.hasRealDates) {
                dateFilterControls.style.display = 'none';
                currentFileDateValues = [];
            }
            // Si hay archivo válido, mantener currentFileDateValues
        }

        function handleDateFilterChange() {
            const selectedFilter = document.querySelector('input[name="dateFilter"]:checked').value;
            const selectedFile = loadedCsvFiles.find(f => f.name === fileList.value);
            
            if (selectedFilter === 'all') {
                dateRangeInputs.classList.add('disabled');
                startDateInput.disabled = true;
                endDateInput.disabled = true;
                dateFilterInfo.textContent = "Mostrando todos los datos disponibles.";
            } else if (selectedFilter === 'range' && selectedFile && selectedFile.hasRealDates) {
                dateRangeInputs.classList.remove('disabled');
                startDateInput.disabled = false;
                endDateInput.disabled = false;
                dateFilterInfo.textContent = "Selecciona las fechas de inicio y fin para filtrar los datos.";
                
                if (!startDateInput.value && currentFileDateValues.length > 0) {
                    const minDate = valueToInputDate(currentFileDateValues[0]);
                    const maxDate = valueToInputDate(currentFileDateValues[currentFileDateValues.length - 1]);
                    startDateInput.value = minDate;
                    endDateInput.value = maxDate;
                }
            }
            
            plotData();
        }

        function handleFileSelection() {
            const selectedFileName = fileList.value;
            resetColumnSelector();
            resetDateControls(); 
            resetChartTypeSelector();
            resetAnalysisControls();
            Plotly.purge(chartContainer);
            chartPlaceholder.classList.remove('hidden');
            chartPlaceholder.textContent = "Selecciona una columna para graficar.";

            if (!selectedFileName) return;

            const selectedFile = loadedCsvFiles.find(f => f.name === selectedFileName);
            if (selectedFile) {
                columnSelector.innerHTML = '<option value="" selected>Selecciona una columna</option>';
                selectedFile.headers.forEach(h => columnSelector.add(new Option(h, h)));
                columnSelector.disabled = false;
                currentFileDateValues = selectedFile.allDates || [];
                
                // Mostrar controles de fecha si hay fechas válidas
                if (selectedFile.hasRealDates && currentFileDateValues.length > 0) {
                    dateFilterControls.style.display = 'block';
                }
            }
        }
        
        function valueToInputDate(value) { 
            if (value == null) return "";
            
            const dateStr = String(value);
            
            const dateTimeMatch = dateStr.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})\s+(\d{1,2})/);
            if (dateTimeMatch) {
                const [, dia, mes, año, hora] = dateTimeMatch;
                const fechaISO = `${año}-${mes.padStart(2, '0')}-${dia.padStart(2, '0')}`;
                return fechaISO;
            }
            
            const d = new Date(dateStr);
            if (!isNaN(d.getTime()) && d.toString() !== "Invalid Date") {
                if (d.getFullYear() > 1000 && d.getFullYear() < 3000) {
                    return d.toISOString().split('T')[0];
                }
            }
            
            return "";
        }

        function setupPlottingControls() { 
            const selectedFile = loadedCsvFiles.find(f => f.name === fileList.value);
            const selectedColumnValue = columnSelector.value;

            resetChartTypeSelector();
            resetAnalysisControls();

            if (!selectedFile || !selectedColumnValue) {
                plotData(); 
                return;
            }
            
            // Configurar controles de fecha solo si el archivo tiene fechas reales
            if (selectedFile.hasRealDates && currentFileDateValues.length > 0) {
                const minDateForInput = valueToInputDate(currentFileDateValues[0]);
                const maxDateForInput = valueToInputDate(currentFileDateValues[currentFileDateValues.length - 1]);

                if (minDateForInput && maxDateForInput) {
                    dateFilterControls.style.display = 'block';
                    startDateInput.min = minDateForInput;
                    startDateInput.max = maxDateForInput;
                    
                    // Solo establecer valores por defecto si no hay valores previos
                    if (!startDateInput.value) startDateInput.value = minDateForInput;
                    if (!endDateInput.value) endDateInput.value = maxDateForInput;
                    
                    endDateInput.min = minDateForInput;
                    endDateInput.max = maxDateForInput;
                    
                    dateFilterInfo.textContent = `Datos disponibles desde ${minDateForInput} hasta ${maxDateForInput}`;
                }
            }

            chartTypeSelector.disabled = false;
            
            // Mostrar controles de análisis si el tipo de gráfico es líneas
            if (chartTypeSelector.value === 'line') {
                analysisControls.style.display = 'block';
            }
            
            plotData(); 
        }

        function handleDateInputChange() {
            if (startDateInput.value && endDateInput.value && startDateInput.value > endDateInput.value) {
                if (this.id === 'startDateInput') endDateInput.value = startDateInput.value; 
                else startDateInput.value = endDateInput.value; 
            }
            plotData();
        }

        function calculateACF(data, maxLag) {
            const n = data.length;
            if (n === 0) return [];
            const mean = data.reduce((a, b) => a + b) / n;
            const variance = data.reduce((acc, val) => acc + (val - mean) * (val - mean), 0);
            
            const acfValues = [];
            for (let lag = 0; lag <= maxLag; lag++) {
                if (lag === 0) {
                    acfValues.push(1);
                    continue;
                }
                if (lag >= n) {
                    acfValues.push(0);
                    continue;
                }
                let covariance = 0;
                for (let i = 0; i < n - lag; i++) {
                    covariance += (data[i] - mean) * (data[i + lag] - mean);
                }
                acfValues.push(variance === 0 ? 0 : covariance / variance);
            }
            return acfValues;
        }

        // Función para calcular la tendencia usando regresión lineal
        function calculateTrend(data) {
            const n = data.length;
            if (n < 2) return new Array(n).fill(null);
            
            const xValues = Array.from({length: n}, (_, i) => i);
            const sumX = xValues.reduce((a, b) => a + b, 0);
            const sumY = data.reduce((a, b) => a + b, 0);
            const sumXY = xValues.reduce((sum, x, i) => sum + x * data[i], 0);
            const sumXX = xValues.reduce((sum, x) => sum + x * x, 0);
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            return xValues.map(x => slope * x + intercept);
        }

        // Función para calcular la estacionalidad
        function calculateSeasonality(data, trend, period = 24) {
            const n = data.length;
            if (n < period * 2) return new Array(n).fill(null);
            
            // Detrended data
            const detrended = data.map((val, i) => val - trend[i]);
            
            // Calculate seasonal pattern
            const seasonalPattern = new Array(period).fill(0);
            const counts = new Array(period).fill(0);
            
            for (let i = 0; i < n; i++) {
                const seasonIndex = i % period;
                seasonalPattern[seasonIndex] += detrended[i];
                counts[seasonIndex]++;
            }
            
            // Average the seasonal components
            for (let i = 0; i < period; i++) {
                if (counts[i] > 0) {
                    seasonalPattern[i] /= counts[i];
                }
            }
            
            // Create full seasonal series
            const seasonal = new Array(n);
            for (let i = 0; i < n; i++) {
                seasonal[i] = seasonalPattern[i % period];
            }
            
            return seasonal;
        }

        // Función para aplicar suavizado de media móvil
        function movingAverage(data, windowSize = 5) {
            const result = [];
            const halfWindow = Math.floor(windowSize / 2);
            
            for (let i = 0; i < data.length; i++) {
                const start = Math.max(0, i - halfWindow);
                const end = Math.min(data.length - 1, i + halfWindow);
                let sum = 0;
                let count = 0;
                
                for (let j = start; j <= end; j++) {
                    if (data[j] !== null && data[j] !== undefined && !isNaN(data[j])) {
                        sum += data[j];
                        count++;
                    }
                }
                
                result[i] = count > 0 ? sum / count : null;
            }
            
            return result;
        }

        function plotData() {
            const selectedFileName = fileList.value;
            const selectedColumn = columnSelector.value;
            const selectedChartType = chartTypeSelector.value;
            const selectedFile = loadedCsvFiles.find(f => f.name === selectedFileName);

            if (!selectedFile || !selectedColumn) { 
                Plotly.purge(chartContainer); 
                chartPlaceholder.classList.remove('hidden');
                chartPlaceholder.textContent = "Selecciona un archivo y una columna para graficar.";
                return; 
            }

            if (!selectedFile.data) return;

            const originalXValues = selectedFile.data.map(row => row._datetimeString);
            const originalYValues = selectedFile.data.map(row => row[selectedColumn]);
            
            let xDataForPlot = [...originalXValues]; 
            let yDataForPlot = [...originalYValues]; 

            // Filtrar por rango de fechas si está activado
            const dateFilterType = document.querySelector('input[name="dateFilter"]:checked').value;
            if (selectedFile.hasRealDates && dateFilterType === 'range' && 
                startDateInput.value && endDateInput.value && 
                !startDateInput.disabled && !endDateInput.disabled) {
                
                const inputStartDate = startDateInput.value; 
                const inputEndDate = endDateInput.value;     
                
                const filteredIndices = [];
                for(let i = 0; i < selectedFile.data.length; i++) {
                    const rowDateTime = selectedFile.data[i]._datetime;
                    const comparableDate = rowDateTime.toISOString().split('T')[0];
                    
                    if (comparableDate >= inputStartDate && comparableDate <= inputEndDate) {
                        filteredIndices.push(i);
                    }
                }
                xDataForPlot = filteredIndices.map(i => originalXValues[i]);
                yDataForPlot = filteredIndices.map(i => originalYValues[i]);
                
                if (filteredIndices.length === 0) {
                    dateFilterInfo.textContent = "No hay datos en el rango de fechas seleccionado.";
                } else {
                    dateFilterInfo.textContent = `Mostrando ${filteredIndices.length} de ${originalXValues.length} registros.`;
                }
            }
            
            const numericYValues = yDataForPlot.map(val => { 
                const num = parseFloat(String(val).replace(',', '.')); 
                return isNaN(num) ? null : num; 
            }).filter(val => val !== null); 

            let plotConfig = [];
            let layout = {
                title: `${selectedChartType.charAt(0).toUpperCase() + selectedChartType.slice(1)} para: ${selectedColumn}`,
                margin: { l: 60, r: 30, b: 80, t: 50 },
                hovermode: 'closest'
            };

            if (numericYValues.length === 0 && selectedChartType !== 'line' && selectedChartType !== 'acf') {
                 Plotly.purge(chartContainer);
                 chartPlaceholder.textContent = "No hay datos numéricos válidos en la columna seleccionada para el rango/tipo especificado.";
                 chartPlaceholder.classList.remove('hidden');
                 return;
            }

            switch (selectedChartType) {
                case 'line':
                    const lineYValues = yDataForPlot.map(val => { 
                        const num = parseFloat(String(val).replace(',', '.')); 
                        return isNaN(num) ? null : num; 
                    });
                    
                    if (xDataForPlot.length === 0 || lineYValues.every(v => v === null)) {
                        Plotly.purge(chartContainer);
                        chartPlaceholder.textContent = "No hay datos para mostrar con el filtro de fecha actual o la columna no es numérica.";
                        chartPlaceholder.classList.remove('hidden');
                        return;
                    }

                    // Filtrar valores nulos para los cálculos
                    const validIndices = [];
                    const validYValues = [];
                    const validXValues = [];
                    
                    lineYValues.forEach((val, index) => {
                        if (val !== null && val !== undefined && !isNaN(val)) {
                            validIndices.push(index);
                            validYValues.push(val);
                            validXValues.push(xDataForPlot[index]);
                        }
                    });

                    plotConfig = [{
                        x: xDataForPlot, 
                        y: lineYValues,
                        type: 'scatter', 
                        mode: 'lines+markers', 
                        name: selectedColumn,
                        line: {shape: 'spline'}, 
                        marker: { size: 4 }
                    }];

                    // Calcular y agregar tendencia y estacionalidad si hay suficientes datos válidos y están habilitados
                    if (validYValues.length >= 10) {
                        const trend = calculateTrend(validYValues);
                        
                        // Agregar tendencia si está marcado el checkbox
                        if (showTrendCheckbox.checked) {
                            const trendSmooth = movingAverage(trend, 5);
                            plotConfig.push({
                                x: validXValues,
                                y: trendSmooth,
                                type: 'scatter',
                                mode: 'lines',
                                name: 'Tendencia',
                                line: { 
                                    color: 'green',
                                    dash: 'dash',
                                    width: 2
                                }
                            });
                        }

                        // Agregar estacionalidad si está marcado el checkbox
                        if (showSeasonalityCheckbox.checked) {
                            const seasonality = calculateSeasonality(validYValues, trend, Math.min(24, Math.floor(validYValues.length / 4)));
                            const seasonalitySmooth = movingAverage(seasonality, 3);
                            
                            // Normalizar estacionalidad para visualización
                            const meanY = validYValues.reduce((a, b) => a + b, 0) / validYValues.length;
                            const normalizedSeasonality = seasonalitySmooth.map(val => val !== null ? meanY + val : null);
                            
                            plotConfig.push({
                                x: validXValues,
                                y: normalizedSeasonality,
                                type: 'scatter',
                                mode: 'lines',
                                name: 'Estacionalidad',
                                line: { 
                                    color: 'red',
                                    dash: 'dash',
                                    width: 2
                                }
                            });
                        }
                    }
                    
                    layout.xaxis = { 
                        title: 'Fecha-Hora',
                        type: 'category',
                        tickangle: -45
                    };
                    layout.yaxis = { title: selectedColumn };
                    layout.showlegend = true;
                    break;
                    
                case 'histogram':
                    if (numericYValues.length === 0) {
                        Plotly.purge(chartContainer);
                        chartPlaceholder.textContent = "No hay datos numéricos para el histograma.";
                        chartPlaceholder.classList.remove('hidden');
                        return;
                    }
                    plotConfig = [{
                        x: numericYValues,
                        type: 'histogram',
                        name: selectedColumn,
                        marker: { color: '#007bff' }
                    }];
                    layout.xaxis = { title: selectedColumn };
                    layout.yaxis = { title: 'Frecuencia' };
                    break;
                    
                case 'boxplot':
                     if (numericYValues.length === 0) {
                        Plotly.purge(chartContainer);
                        chartPlaceholder.textContent = "No hay datos numéricos para el diagrama de caja.";
                        chartPlaceholder.classList.remove('hidden');
                        return;
                    }
                    plotConfig = [{
                        y: numericYValues, 
                        type: 'box',
                        name: selectedColumn,
                        marker: { color: '#28a745' }
                    }];
                    layout.xaxis = { title: '' };
                    layout.yaxis = { title: selectedColumn };
                    break;
                    
                case 'acf':
                    if (numericYValues.length < 2) {
                        Plotly.purge(chartContainer);
                        chartPlaceholder.textContent = "Se necesitan al menos 2 puntos de datos numéricos para calcular ACF.";
                        chartPlaceholder.classList.remove('hidden');
                        return;
                    }
                    const maxLag = Math.min(numericYValues.length - 1, 40);
                    const acfValues = calculateACF(numericYValues, maxLag); 
                    const lags = Array.from({length: acfValues.length}, (_, i) => i);
                    const confidenceLimit = 1.96 / Math.sqrt(numericYValues.length);
                    
                    plotConfig = [
                        { 
                            x: lags, 
                            y: acfValues, 
                            type: 'bar', 
                            name: 'ACF', 
                            marker: { color: '#ff7f0e' } 
                        },
                        { 
                            x: [lags[0], lags[lags.length - 1]], 
                            y: [confidenceLimit, confidenceLimit], 
                            type: 'scatter', 
                            mode: 'lines', 
                            name: 'Conf. Superior', 
                            line: { color: 'rgba(0,0,0,0.5)', dash: 'dash' } 
                        },
                        { 
                            x: [lags[0], lags[lags.length - 1]], 
                            y: [-confidenceLimit, -confidenceLimit], 
                            type: 'scatter', 
                            mode: 'lines', 
                            name: 'Conf. Inferior', 
                            line: { color: 'rgba(0,0,0,0.5)', dash: 'dash' } 
                        }
                    ];
                    layout.xaxis = { title: 'Lag' };
                    layout.yaxis = { title: 'Autocorrelación', range: [-1, 1] };
                    layout.showlegend = true;
                    break;
                    
                default:
                    Plotly.purge(chartContainer);
                    chartPlaceholder.textContent = "Tipo de gráfico no reconocido.";
                    chartPlaceholder.classList.remove('hidden');
                    return;
            }

            if (plotConfig.length > 0 && plotConfig.some(trace => (trace.x && trace.x.length > 0) || (trace.y && trace.y.length > 0))) {
                chartPlaceholder.classList.add('hidden');
                Plotly.newPlot(chartContainer, plotConfig, layout, {responsive: true});
            } else {
                Plotly.purge(chartContainer);
                chartPlaceholder.textContent = "No hay datos para mostrar con la configuración actual.";
                chartPlaceholder.classList.remove('hidden');
            }
        }

        updateFileList();
    </script>
</body>
</html>