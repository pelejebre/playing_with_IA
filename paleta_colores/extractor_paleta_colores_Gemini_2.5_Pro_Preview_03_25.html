<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extractor de Paleta de Colores</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>游꿛</text></svg>">

    <style>
        /* --- INICIO CSS (Sin cambios respecto a la versi칩n anterior) --- */
        :root {
            --primary-color: #4a90e2;
            --secondary-color: #f5f5f5;
            --text-color: #333;
            --border-color: #ddd;
            --background-color: #ffffff;
            --shadow-color: rgba(0, 0, 0, 0.1);
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            font-family: var(--font-family);
            margin: 0;
            padding: 0;
            background-color: var(--secondary-color);
            color: var(--text-color);
            line-height: 1.6;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        header {
            background-color: var(--primary-color);
            color: white;
            padding: 1rem 0;
            text-align: center;
            box-shadow: 0 2px 4px var(--shadow-color);
        }

        header h1 {
            margin: 0;
            font-size: 1.8rem;
        }

        main {
            flex: 1; /* Ocupa el espacio restante */
            max-width: 1000px;
            margin: 2rem auto;
            padding: 1rem 2rem;
            background-color: var(--background-color);
            border-radius: 8px;
            box-shadow: 0 4px 8px var(--shadow-color);
        }

        section {
            margin-bottom: 2.5rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }
        section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        h2 {
            color: var(--primary-color);
            margin-top: 0;
            border-bottom: 2px solid var(--primary-color);
            display: inline-block;
            padding-bottom: 0.3rem;
            margin-bottom: 1rem;
        }

        .button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.3s ease, transform 0.1s ease;
            margin-right: 10px;
        }

        .button:hover:not(:disabled) {
            background-color: #357abd;
            transform: translateY(-1px);
        }
        .button:active:not(:disabled) {
            transform: translateY(0px);
        }

        .button:disabled {
            background-color: #a0c7e4;
            cursor: not-allowed;
        }

        .upload-section {
            text-align: center;
        }
        .file-name {
            margin-top: 0.5rem;
            font-style: italic;
            color: #666;
            min-height: 1.2em; /* Evita saltos de layout */
        }

        .preview-section {
            text-align: center;
        }

        #imagePreviewContainer {
            position: relative;
            width: 100%;
            max-width: 500px; /* Limita tama침o m치ximo */
            min-height: 200px; /* Altura m칤nima */
            margin: 1rem auto;
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #fafafa;
            overflow: hidden; /* Para que la imagen no se salga */
        }

        #imagePreview {
            display: none; /* Oculta inicialmente */
            max-width: 100%;
            max-height: 400px;
            object-fit: contain; /* Mantiene la proporci칩n, ajusta dentro */
            border-radius: 6px;
        }
        #previewPlaceholder {
            color: #999;
            font-style: italic;
        }

        .loading {
            margin-top: 1rem;
            color: var(--primary-color);
            font-weight: bold;
        }

        .palette-info {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 1rem;
            min-height: 1.2em;
        }

        .palette-container {
            display: flex;
            flex-wrap: wrap;
            gap: 15px; /* Espacio entre bloques */
            justify-content: center; /* Centra los bloques si no llenan la fila */
            margin-top: 1rem;
        }

        .color-block {
            width: 130px; /* Ancho fijo para consistencia */
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 5px var(--shadow-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between; /* Espacia contenido interno */
            text-align: center;
            position: relative;
            overflow: hidden; /* Para el input de color */
            transition: transform 0.2s ease;
        }
        .color-block:hover {
            transform: translateY(-3px);
        }

        .color-block-info {
            background-color: rgba(255, 255, 255, 0.8); /* Fondo semitransparente para legibilidad */
            padding: 8px;
            border-radius: 4px;
            margin-top: 10px; /* Espacio desde el borde superior o color picker */
            width: calc(100% - 16px); /* Ajusta al padding */
        }

        .color-block p {
            margin: 3px 0;
            font-size: 0.9rem;
            font-weight: bold;
            color: #333; /* Asegura contraste sobre fondo blanco */
            word-break: break-all; /* Evita que el texto se salga */
        }
        .color-block p span {
            font-weight: normal;
            font-family: 'Courier New', Courier, monospace; /* Monoespaciado para c칩digos */
        }

        /* Estilo para el input de color (editor manual) */
        .color-input {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            width: 30px;
            height: 30px;
            border: none;
            border-radius: 50%; /* C칤rculo */
            cursor: pointer;
            padding: 0;
            margin-bottom: 10px;
            position: absolute;
            top: 10px;
            right: 10px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            background-color: transparent; /* El color lo da el navegador */
        }
        /* Elimina el borde por defecto en algunos navegadores */
        .color-input::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        .color-input::-webkit-color-swatch {
            border: 1px solid #ccc;
            border-radius: 50%;
        }
        .color-input::-moz-color-swatch {
            border: 1px solid #ccc;
            border-radius: 50%;
        }

        .actions-section {
            text-align: center;
        }
        .action-buttons {
            margin-bottom: 1.5rem;
        }

        .share-link-container {
            margin-top: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap; /* Para pantallas peque침as */
        }
        .share-link-container label {
            margin-right: 5px;
            font-weight: bold;
        }
        #shareLink {
            flex-grow: 1; /* Ocupa espacio disponible */
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 0.9rem;
            min-width: 250px; /* Ancho m칤nimo */
        }
        .copy-button {
            padding: 8px 15px;
            font-size: 0.9rem;
            white-space: nowrap; /* Evita que el texto se parta */
        }

        footer {
            text-align: center;
            margin-top: 2rem;
            padding: 1rem;
            background-color: #e0e0e0;
            color: #666;
            font-size: 0.9rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            main {
                margin: 1rem;
                padding: 1rem;
            }
            header h1 {
                font-size: 1.5rem;
            }
            .color-block {
                width: 110px; /* M치s peque침o en m칩viles */
                padding: 10px;
            }
            .color-block p {
                font-size: 0.8rem;
            }
            .color-input {
                width: 25px;
                height: 25px;
                top: 5px;
                right: 5px;
            }
            .action-buttons {
                display: flex;
                flex-direction: column;
                gap: 10px;
                align-items: center;
            }
            .button {
                width: 80%;
                max-width: 250px;
                margin-right: 0;
            }
            .share-link-container {
                flex-direction: column;
                align-items: stretch;
            }
            #shareLink {
                width: calc(100% - 24px); /* Ajuste padding/border */
                margin-bottom: 10px;
            }
            .copy-button {
                width: 100%;
            }
        }

        @media (max-width: 480px) {
            header h1 {
                font-size: 1.3rem;
            }
            .palette-container {
                gap: 10px;
            }
            .color-block {
                width: calc(50% - 25px); /* 2 columnas en m칩viles, ajustando gap y padding */
            }
        }
        /* --- FIN CSS --- */
    </style>

</head>
<body>
    <header>
        <h1>游꿛 Extractor de Paleta de Colores</h1>
    </header>

    <main>
        <section class="upload-section">
            <input type="file" id="imageUpload" accept="image/*" hidden>
            <button id="uploadButton" class="button">Subir Imagen</button>
            <p id="fileName" class="file-name"></p>
        </section>

        <section class="preview-section">
            <h2>Vista Previa</h2>
            <div id="imagePreviewContainer">
                <img id="imagePreview" src="#" alt="Vista previa de la imagen">
                <p id="previewPlaceholder">Aqu칤 se mostrar치 la imagen cargada.</p>
            </div>
            <div id="loadingIndicator" class="loading" style="display: none;">Extrayendo colores...</div>
        </section>

        <section class="palette-section">
            <h2>Paleta de Colores Generada</h2>
            <p id="paletteInfo" class="palette-info"></p>
            <div id="paletteContainer" class="palette-container">
                <!-- Los bloques de color se insertar치n aqu칤 -->
            </div>
        </section>

        <section class="actions-section">
            <h2>Acciones</h2>
            <div class="action-buttons">
                <button id="savePaletteButton" class="button" disabled>Guardar Paleta (JSON)</button>
                <button id="sharePaletteButton" class="button" disabled>Compartir Paleta</button>
            </div>
            <div id="shareLinkContainer" class="share-link-container" style="display: none;">
                <label for="shareLink">Enlace para compartir:</label>
                <input type="text" id="shareLink" readonly>
                <button id="copyLinkButton" class="button copy-button">Copiar</button>
            </div>
        </section>
    </main>

    <footer>
        <p>Creado con HTML, CSS y JavaScript puro.</p>
    </footer>

    <script>
        /*!
         * Color Thief v2.4.0
         * by Lokesh Dhakar - https://lokeshdhakar.com
         * (License details omitted for brevity in this example, but were present in the original)
         */

        /*
          CanvasImage Class
          Class that wraps the html image element and canvas.
          It also simplifies some of the canvas context manipulation
          with a set of helper functions.
        */
        const CanvasImage = function (image) {
            this.canvas = document.createElement('canvas');
            // *** ASEGURARSE DE QUE ESTA OPCI칍N EST츼 AQU칈 ***
            this.context = this.canvas.getContext('2d', { willReadFrequently: true });
            // Usar naturalWidth/Height para obtener tama침o real de la imagen
            this.width = this.canvas.width = image.naturalWidth;
            this.height = this.canvas.height = image.naturalHeight;
            // Dibujar la imagen en el canvas
            this.context.drawImage(image, 0, 0, this.width, this.height);
        };

        CanvasImage.prototype.getImageData = function () {
            // Control de errores b치sico si el canvas no tiene tama침o
            if (this.width === 0 || this.height === 0) {
                console.error("CanvasImage Error: Image has zero dimensions.");
                return null;
            }
            try {
                return this.context.getImageData(0, 0, this.width, this.height);
            } catch(e) {
                console.error("CanvasImage Error: Failed to getImageData.", e);
                // Si es un SecurityError, podr칤a ser un problema de cross-origin inesperado
                if (e.name === 'SecurityError') {
                    console.error("This might be a cross-origin issue, even with FileReader. Check browser security settings or extensions.");
                }
                return null;
            }
        };

        /*!
         * quantize.js Copyright 2008 Nick Rabinowitz.
         * (License details omitted for brevity)
         * ... (Resto del c칩digo de quantize.js y Color Thief sin cambios) ...
         */

        // --- PEGAR AQU칈 EL RESTO DEL C칍DIGO DE COLOR THIEF (quantize.js y la clase ColorThief) ---
        // ... (el c칩digo es largo, as칤 que lo omito aqu칤, pero debe estar presente como en la respuesta anterior) ...
         const VBOX_LENGTH = 8; const FRACT_BY_POPULATIONS = 0.75; const MAX_ITERATIONS = 1000; const SIGBITS = 5; function getColorIndex(r, g, b) { return (r << (2 * SIGBITS)) + (g << SIGBITS) + b; } class Histogram { constructor(pixels) { this.histogram = {}; this.indexList = []; pixels.forEach(pixel => { const index = getColorIndex( pixel[0] >> (8 - SIGBITS), pixel[1] >> (8 - SIGBITS), pixel[2] >> (8 - SIGBITS) ); if (!this.histogram[index]) { this.histogram[index] = 0; this.indexList.push(index); } this.histogram[index]++; }); } } class PQueue { constructor(comparator) { this.comparator = comparator; this.contents = []; this.sorted = false; } sort() { if (!this.sorted) { this.contents.sort(this.comparator); this.sorted = true; } } push(o) { this.contents.push(o); this.sorted = false; } peek(index = this.contents.length - 1) { this.sort(); return this.contents[index]; } pop() { this.sort(); return this.contents.pop(); } size() { return this.contents.length; } map(f) { this.sort(); return this.contents.map(f); } } class VBox { constructor(r1, r2, g1, g2, b1, b2, histogramData) { this.r1 = r1; this.r2 = r2; this.g1 = g1; this.g2 = g2; this.b1 = b1; this.b2 = b2; this.histogram = histogramData.histogram; this.indexList = histogramData.indexList; this._volume = -1; this._count = -1; this._avg = null; } volume(force = false) { if (this._volume < 0 || force) { this._volume = ((this.r2 - this.r1 + 1) * (this.g2 - this.g1 + 1) * (this.b2 - this.b1 + 1)); } return this._volume; } count(force = false) { if (this._count < 0 || force) { let npix = 0; for (const index of this.indexList) { const r = (index >> (2 * SIGBITS)) & ((1 << SIGBITS) - 1); const g = (index >> SIGBITS) & ((1 << SIGBITS) - 1); const b = index & ((1 << SIGBITS) - 1); if (r >= this.r1 && r <= this.r2 && g >= this.g1 && g <= this.g2 && b >= this.b1 && b <= this.b2) { npix += this.histogram[index] || 0; } } this._count = npix; } return this._count; } avg(force = false) { if (this._avg === null || force) { let mult = 1 << (8 - SIGBITS); let rsum = 0, gsum = 0, bsum = 0, hval; let ntot = 0; for (const index of this.indexList) { hval = this.histogram[index] || 0; if (hval === 0) continue; const r_histo = (index >> (2 * SIGBITS)) & ((1 << SIGBITS) - 1); const g_histo = (index >> SIGBITS) & ((1 << SIGBITS) - 1); const b_histo = index & ((1 << SIGBITS) - 1); if (r_histo >= this.r1 && r_histo <= this.r2 && g_histo >= this.g1 && g_histo <= this.g2 && b_histo >= this.b1 && b_histo <= this.b2) { ntot += hval; rsum += (hval * (r_histo + 0.5) * mult); gsum += (hval * (g_histo + 0.5) * mult); bsum += (hval * (b_histo + 0.5) * mult); } } if (ntot > 0) { this._avg = [~~(rsum / ntot), ~~(gsum / ntot), ~~(bsum / ntot)]; } else { this._avg = [ ~~(mult * (this.r1 + this.r2 + 1) / 2), ~~(mult * (this.g1 + this.g2 + 1) / 2), ~~(mult * (this.b1 + this.b2 + 1) / 2) ]; } } return this._avg; } contains(pixel) { const rval = pixel[0] >> (8 - SIGBITS); const gval = pixel[1] >> (8 - SIGBITS); const bval = pixel[2] >> (8 - SIGBITS); return (rval >= this.r1 && rval <= this.r2 && gval >= this.g1 && gval <= this.g2 && bval >= this.b1 && bval <= this.b2); } } class CMap { constructor() { this.vboxes = new PQueue((a, b) => { const aCount = a.vbox.count(); const bCount = b.vbox.count(); const aVolume = a.vbox.volume(); const bVolume = b.vbox.volume(); if(aCount === 0 && bCount === 0) return aVolume - bVolume; if(aCount === 0) return 1; if(bCount === 0) return -1; return aCount * aVolume - bCount * bVolume; }); } push(vbox) { this.vboxes.push({ vbox: vbox, color: vbox.avg() }); } palette() { return this.vboxes.map(vb => vb.color); } size() { return this.vboxes.size(); } map(color) { const vboxes = this.vboxes; for (let i = 0; i < vboxes.size(); i++) { if (vboxes.peek(i).vbox.contains(color)) { return vboxes.peek(i).color; } } return this.nearest(color); } nearest(color) { let d1 = Number.MAX_VALUE; let pColor = null; const vboxes = this.vboxes; for (let i = 0; i < vboxes.size(); i++) { let vbColor = vboxes.peek(i).color; let d2 = Math.sqrt( Math.pow(color[0] - vbColor[0], 2) + Math.pow(color[1] - vbColor[1], 2) + Math.pow(color[2] - vbColor[2], 2) ); if (d2 < d1) { d1 = d2; pColor = vbColor; } } return pColor; } } function quantize(pixels, maxcolors) { if (!pixels.length || maxcolors < 2 || maxcolors > 256) { return false; } const histogramData = new Histogram(pixels); let rmin = 1000000, rmax = 0; let gmin = 1000000, gmax = 0; let bmin = 1000000, bmax = 0; let r, g, b; for (const index of histogramData.indexList) { r = (index >> (2 * SIGBITS)) & ((1 << SIGBITS) - 1); g = (index >> SIGBITS) & ((1 << SIGBITS) - 1); b = index & ((1 << SIGBITS) - 1); if (r < rmin) rmin = r; else if (r > rmax) rmax = r; if (g < gmin) gmin = g; else if (g > gmax) gmax = g; if (b < bmin) bmin = b; else if (b > bmax) bmax = b; } const vbox = new VBox(rmin, rmax, gmin, gmax, bmin, bmax, histogramData); const pq = new PQueue((a, b) => a.vbox.count() * a.vbox.volume() - b.vbox.count() * b.vbox.volume()); pq.push({ vbox: vbox, color: vbox.avg() }); function iterativeQuantization(pq, target) { let ncolors = 1; let niters = 0; while (niters < MAX_ITERATIONS) { let pqVal = pq.pop(); if (!pqVal) break; let vbox = pqVal.vbox; if (!vbox.count()) { continue; } let rw = vbox.r2 - vbox.r1 + 1; let gw = vbox.g2 - vbox.g1 + 1; let bw = vbox.b2 - vbox.b1 + 1; let maxw = Math.max(rw, gw, bw); if (vbox.count() === 1) { break; } let total = 0; let partialsum = new Array(32).fill(0); let lookaheadsum = new Array(32).fill(0); let index, i, j, k, sum, hval; let cutDim; if (maxw === rw) { cutDim = 'r'; for (i = vbox.r1; i <= vbox.r2; i++) { sum = 0; for (j = vbox.g1; j <= vbox.g2; j++) { for (k = vbox.b1; k <= vbox.b2; k++) { index = getColorIndex(i, j, k); hval = histogramData.histogram[index] || 0; sum += hval; } } total += sum; partialsum[i] = total; } } else if (maxw === gw) { cutDim = 'g'; for (i = vbox.g1; i <= vbox.g2; i++) { sum = 0; for (j = vbox.r1; j <= vbox.r2; j++) { for (k = vbox.b1; k <= vbox.b2; k++) { index = getColorIndex(j, i, k); hval = histogramData.histogram[index] || 0; sum += hval; } } total += sum; partialsum[i] = total; } } else { cutDim = 'b'; for (i = vbox.b1; i <= vbox.b2; i++) { sum = 0; for (j = vbox.r1; j <= vbox.r2; j++) { for (k = vbox.g1; k <= vbox.g2; k++) { index = getColorIndex(j, k, i); hval = histogramData.histogram[index] || 0; sum += hval; } } total += sum; partialsum[i] = total; } } partialsum.forEach((d, ii) => { lookaheadsum[ii] = total - d }); let dim1 = vbox[cutDim + '1']; let dim2 = vbox[cutDim + '2']; let splitPoint = -1; for (i = dim1; i <= dim2; i++) { if (partialsum[i] > total / 2) { splitPoint = i; break; } } if (splitPoint === -1) { continue; } let vbox1 = { ...vbox }; let vbox2 = { ...vbox }; vbox1[cutDim + '2'] = splitPoint; vbox2[cutDim + '1'] = splitPoint + 1; let newVbox1 = new VBox(vbox1.r1, vbox1.r2, vbox1.g1, vbox1.g2, vbox1.b1, vbox1.b2, histogramData); let newVbox2 = new VBox(vbox2.r1, vbox2.r2, vbox2.g1, vbox2.g2, vbox2.b1, vbox2.b2, histogramData); if (newVbox1.count() > 0) pq.push({ vbox: newVbox1, color: newVbox1.avg() }); if (newVbox2.count() > 0) pq.push({ vbox: newVbox2, color: newVbox2.avg() }); ncolors++; if (ncolors >= target) break; if (niters++ > MAX_ITERATIONS) break; } } iterativeQuantization(pq, FRACT_BY_POPULATIONS * maxcolors); const cmap = new CMap(); while(pq.size()){ cmap.push(pq.pop().vbox); } return cmap; } function getPixels(imgData, quality) { const pixels = []; if (!imgData || !imgData.data) return pixels; const data = imgData.data; const len = imgData.width * imgData.height; const pixelCount = len; const sample = Math.max(1, Math.floor(pixelCount / (quality * 1000))); for (let i = 0; i < pixelCount; i += sample) { let offset = i * 4; let r = data[offset + 0]; let g = data[offset + 1]; let b = data[offset + 2]; let a = data[offset + 3]; if (a === undefined || a >= 125) { if (!(r > 245 && g > 245 && b > 245)) { pixels.push([r, g, b]); } } } return pixels; } class ColorThief { getColor(sourceImage, quality = 10) { const palette = this.getPalette(sourceImage, 5, quality); return palette ? palette[0] : null; } getPalette(sourceImage, colorCount = 10, quality = 10) { if (typeof colorCount === 'undefined' || colorCount < 2 || colorCount > 256) { colorCount = 10; } if (typeof quality === 'undefined' || quality < 1) { quality = 10; } try { const image = new CanvasImage(sourceImage); const imageData = image.getImageData(); if (!imageData) { console.error("ColorThief Error: Could not get imageData from CanvasImage."); return null; } const pixels = getPixels(imageData, quality); if (pixels.length === 0) { console.error("ColorThief Error: No pixels found after filtering."); return null; } const cmap = quantize(pixels, colorCount); const palette = cmap ? cmap.palette() : null; return palette; } catch (error) { console.error("ColorThief Error during getPalette:", error); return null; } } }
        // --- FIN Color Thief ---
    </script>


    <script>
        // --- INICIO SCRIPT PRINCIPAL (con correcciones en handleImageUpload) ---
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements (sin cambios) ---
            const uploadButton = document.getElementById('uploadButton');
            const imageUpload = document.getElementById('imageUpload');
            const fileNameDisplay = document.getElementById('fileName');
            const imagePreview = document.getElementById('imagePreview');
            const imagePreviewContainer = document.getElementById('imagePreviewContainer');
            const previewPlaceholder = document.getElementById('previewPlaceholder');
            const paletteContainer = document.getElementById('paletteContainer');
            const loadingIndicator = document.getElementById('loadingIndicator');
            const savePaletteButton = document.getElementById('savePaletteButton');
            const sharePaletteButton = document.getElementById('sharePaletteButton');
            const shareLinkContainer = document.getElementById('shareLinkContainer');
            const shareLinkInput = document.getElementById('shareLink');
            const copyLinkButton = document.getElementById('copyLinkButton');
            const paletteInfo = document.getElementById('paletteInfo');

            // --- Global State (sin cambios) ---
            let currentPalette = [];
            const colorThief = new ColorThief();
            const PALETTE_SIZE = 6;

            // --- Event Listeners (sin cambios) ---
            uploadButton.addEventListener('click', () => imageUpload.click());
            imageUpload.addEventListener('change', handleImageUpload);
            savePaletteButton.addEventListener('click', savePaletteToFile);
            sharePaletteButton.addEventListener('click', generateShareLink);
            copyLinkButton.addEventListener('click', copyShareLink);

            // --- Initialization (sin cambios) ---
            checkUrlForPalette();

            // --- Functions ---

            function handleImageUpload(event) {
                const file = event.target.files[0];
                if (!file) {
                    resetUI(); // Asegurarse de resetear si no hay archivo
                    return;
                }

                if (!file.type.startsWith('image/')) {
                    alert('Por favor, selecciona un archivo de imagen v치lido (JPEG, PNG, GIF, WebP, etc.).');
                    resetUI();
                    return;
                }

                // Resetear UI antes de empezar a cargar
                resetUI(); // Llama a resetUI para limpiar estado previo ANTES de cargar
                fileNameDisplay.textContent = `Archivo: ${file.name}`;
                previewPlaceholder.style.display = 'none';
                imagePreview.style.display = 'block'; // Mostrar img aunque a칰n no tenga src
                loadingIndicator.style.display = 'block';
                resetActionButtons(); // Deshabilitar botones

                const reader = new FileReader();

                reader.onload = function(e) {
                    // Asignar el Data URL al src del <img>
                    imagePreview.src = e.target.result;

                    // *** Evento crucial: procesar DESPU칄S de que la imagen est칠 lista en <img> ***
                    imagePreview.onload = () => {
                        // *** Verificaci칩n Adicional ***: Asegurar que la imagen tiene dimensiones
                        if (imagePreview.naturalWidth === 0 || imagePreview.naturalHeight === 0) {
                            console.error("Error: La imagen cargada no tiene dimensiones v치lidas.");
                            alert("Error al cargar las dimensiones de la imagen. Intenta con otra.");
                            resetUI();
                            loadingIndicator.style.display = 'none';
                            return; // Salir si no hay dimensiones
                        }

                        // Usar setTimeout para dar un respiro al navegador (mitiga race conditions)
                        setTimeout(() => {
                            try {
                                console.log("Intentando extraer paleta...");
                                // Extraer paleta de colores usando Color Thief
                                const paletteRgb = colorThief.getPalette(imagePreview, PALETTE_SIZE);

                                // *** Verificaci칩n Adicional ***: Comprobar si Color Thief devolvi칩 algo
                                if (!paletteRgb || paletteRgb.length === 0) {
                                     // Puede devolver null o un array vac칤o si falla
                                     console.error("Color Thief no pudo extraer una paleta.");
                                     throw new Error("Color Thief returned no palette. Check image format/content or library errors.");
                                }

                                console.log("Paleta RGB extra칤da:", paletteRgb);

                                currentPalette = paletteRgb.map(rgb => {
                                    // Validar RGB antes de convertir (asegura que sean n칰meros)
                                    if (typeof rgb?.[0] !== 'number' || typeof rgb?.[1] !== 'number' || typeof rgb?.[2] !== 'number') {
                                        console.warn("Color inv치lido en paleta:", rgb);
                                        return null; // Marcar como inv치lido
                                    }
                                    return {
                                        rgb: rgb,
                                        hex: rgbToHex(rgb[0], rgb[1], rgb[2])
                                    };
                                }).filter(color => color !== null); // Filtrar colores inv치lidos

                                if (currentPalette.length === 0) {
                                     throw new Error("No valid colors found in the extracted palette.");
                                }

                                displayPalette(currentPalette);
                                enableActionButtons();
                                paletteInfo.textContent = `Se encontraron ${currentPalette.length} colores predominantes. Puedes hacer clic en el c칤rculo de color para ajustarlos.`;

                            } catch (error) {
                                // *** Log detallado del error ***
                                console.error("Error detallado al extraer la paleta:", error);
                                alert(`Hubo un error al procesar la imagen: ${error.message || 'Error desconocido'}. Revisa la consola para m치s detalles.`);
                                resetUI(); // Restablecer en caso de error
                            } finally {
                                loadingIndicator.style.display = 'none'; // Ocultar carga SIEMPRE
                            }
                        }, 100); // Aumentado ligeramente el delay a 100ms, ajustar si es necesario
                    }

                    // Manejador de error para el <img>
                    imagePreview.onerror = () => {
                        console.error("Error: No se pudo cargar la imagen en el elemento <img> (onerror activado).");
                        alert("No se pudo cargar la vista previa de la imagen. El archivo podr칤a estar corrupto o ser incompatible.");
                        resetUI();
                        loadingIndicator.style.display = 'none';
                    }
                }

                // Manejador de error para FileReader
                reader.onerror = () => {
                    console.error("Error: FileReader no pudo leer el archivo.");
                    alert("Hubo un error al leer el archivo seleccionado.");
                    resetUI();
                    loadingIndicator.style.display = 'none';
                }

                // Iniciar la lectura del archivo
                reader.readAsDataURL(file);
            }

            // --- Resto de funciones (displayPalette, handleColorEdit, savePaletteToFile, etc. sin cambios) ---
            function displayPalette(palette) {
                paletteContainer.innerHTML = ''; // Limpiar contenedor
                palette.forEach((color, index) => {
                    const colorBlock = document.createElement('div');
                    colorBlock.classList.add('color-block');
                    colorBlock.style.backgroundColor = color.hex;
                    colorBlock.dataset.index = index; // Guardar 칤ndice para edici칩n

                    const colorInput = document.createElement('input');
                    colorInput.type = 'color';
                    colorInput.classList.add('color-input');
                    colorInput.value = color.hex;
                    colorInput.title = 'Haz clic para editar este color';

                    const colorInfoDiv = document.createElement('div');
                    colorInfoDiv.classList.add('color-block-info');

                    const hexText = document.createElement('p');
                    hexText.innerHTML = `HEX: <span class="hex-value">${color.hex}</span>`;

                    const rgbText = document.createElement('p');
                    rgbText.innerHTML = `RGB: <span class="rgb-value">(${color.rgb.join(', ')})</span>`;

                    colorInput.addEventListener('input', (e) => handleColorEdit(e, index));
                    colorInput.addEventListener('change', (e) => handleColorEdit(e, index));

                    colorInfoDiv.appendChild(hexText);
                    colorInfoDiv.appendChild(rgbText);
                    colorBlock.appendChild(colorInput);
                    colorBlock.appendChild(colorInfoDiv);
                    paletteContainer.appendChild(colorBlock);
                });
            }

            function handleColorEdit(event, index) {
                const newHex = event.target.value;
                const newRgb = hexToRgb(newHex);
                if (!newRgb) return;
                currentPalette[index] = { hex: newHex, rgb: newRgb };
                const block = paletteContainer.querySelector(`.color-block[data-index="${index}"]`);
                if (block) {
                    block.style.backgroundColor = newHex;
                    block.querySelector('.hex-value').textContent = newHex;
                    block.querySelector('.rgb-value').textContent = `(${newRgb.join(', ')})`;
                }
                shareLinkContainer.style.display = 'none';
                shareLinkInput.value = '';
            }

            function savePaletteToFile() {
                if (currentPalette.length === 0) return;
                const paletteToSave = {
                    name: `Paleta de ${fileNameDisplay.textContent || 'imagen cargada'}`,
                    colors: currentPalette.map(c => ({ hex: c.hex, rgb: `rgb(${c.rgb.join(',')})` })),
                    generatedAt: new Date().toISOString()
                };
                const dataStr = JSON.stringify(paletteToSave, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'color_palette.json';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            }

            function generateShareLink() {
                if (currentPalette.length === 0) return;
                const hexColors = currentPalette.map(c => c.hex.substring(1));
                const encodedColors = hexColors.join(',');
                const url = new URL(window.location.origin + window.location.pathname);
                url.search = `?palette=${encodedColors}`;
                shareLinkInput.value = url.toString();
                shareLinkContainer.style.display = 'flex';
                copyLinkButton.textContent = 'Copiar';
            }

             function copyShareLink() {
                 if (!navigator.clipboard) {
                    shareLinkInput.select();
                    try {
                        document.execCommand('copy');
                        copyLinkButton.textContent = '춰Copiado!';
                    } catch (err) {
                        console.warn('Fallback de copiado fall칩:', err);
                         alert('No se pudo copiar el enlace autom치ticamente. Por favor, c칩pialo manualmente.');
                         copyLinkButton.textContent = 'Error';
                    }
                     window.getSelection().removeAllRanges();
                    return;
                }
                navigator.clipboard.writeText(shareLinkInput.value).then(() => {
                    copyLinkButton.textContent = '춰Copiado!';
                    setTimeout(() => { copyLinkButton.textContent = 'Copiar'; }, 2000);
                }).catch(err => {
                    console.error('Error al copiar al portapapeles:', err);
                    alert('No se pudo copiar el enlace al portapapeles.');
                    copyLinkButton.textContent = 'Error';
                });
            }

             function checkUrlForPalette() {
                const params = new URLSearchParams(window.location.search);
                if (params.has('palette')) {
                    const encodedColors = params.get('palette');
                    const hexColorsRaw = encodedColors.split(',');
                    const importedPalette = hexColorsRaw.map(hexRaw => {
                        const hex = '#' + hexRaw.trim().toUpperCase();
                        if (/^#[0-9A-F]{6}$/i.test(hex)) {
                            const rgb = hexToRgb(hex);
                            return rgb ? { hex, rgb } : null;
                        }
                         console.warn(`Formato HEX inv치lido encontrado en URL: ${hexRaw}`);
                        return null;
                    }).filter(color => color !== null);
                    if (importedPalette.length > 0) {
                        currentPalette = importedPalette;
                        displayPalette(currentPalette);
                        enableActionButtons();
                        previewPlaceholder.style.display = 'none';
                        imagePreview.style.display = 'none';
                        imagePreviewContainer.style.borderStyle = 'solid';
                        fileNameDisplay.textContent = 'Paleta cargada desde URL';
                        paletteInfo.textContent = `Paleta importada con ${currentPalette.length} colores. Puedes editarlos.`;
                    } else {
                         paletteInfo.textContent = 'La paleta en la URL no conten칤a colores v치lidos.';
                    }
                }
            }

            function resetUI() {
                fileNameDisplay.textContent = '';
                imagePreview.src = '#'; // Limpiar src
                imagePreview.style.display = 'none';
                imagePreviewContainer.style.borderStyle = 'dashed';
                previewPlaceholder.style.display = 'block';
                paletteContainer.innerHTML = '';
                paletteInfo.textContent = '';
                currentPalette = [];
                resetActionButtons();
                shareLinkContainer.style.display = 'none';
                shareLinkInput.value = '';
                imageUpload.value = ''; // Importante para permitir subir el mismo archivo de nuevo
                loadingIndicator.style.display = 'none'; // Asegurarse de ocultar el indicador
            }

            function resetActionButtons() {
                savePaletteButton.disabled = true;
                sharePaletteButton.disabled = true;
                shareLinkContainer.style.display = 'none';
                shareLinkInput.value = '';
            }
            function enableActionButtons() {
                savePaletteButton.disabled = false;
                sharePaletteButton.disabled = false;
            }

            function rgbToHex(r, g, b) {
                r = Math.max(0, Math.min(255, Math.round(r)));
                g = Math.max(0, Math.min(255, Math.round(g)));
                b = Math.max(0, Math.min(255, Math.round(b)));
                return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
            }

            function hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? [ parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16) ] : null;
            }
        });
         // --- FIN SCRIPT PRINCIPAL ---
    </script>

</body>
</html>